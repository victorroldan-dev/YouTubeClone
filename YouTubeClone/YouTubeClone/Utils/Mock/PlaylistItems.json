{
    "kind": "youtube#playlistItemListResponse",
    "etag": "94QaNW0w5Shdf_4NnPmJjY9QtXg",
    "items": [
        {
            "kind": "youtube#playlistItem",
            "etag": "rfQRP9Ia8XhEm_Fe4pu3EpbZORc",
            "id": "UExUX09PYktaM0NwdU5FMHQ4ckNXa0FyZnBUZ2tKUDlsbS41NkI0NEY2RDEwNTU3Q0M2",
            "snippet": {
                "publishedAt": "2021-10-23T04:53:22Z",
                "channelId": "UC_I_lCplbwIf60iUgsTE79g",
                "title": "Manejo de Memoria - Value Type y Reference Type - iOS - Swift 1/3",
                "description": "Este es el primer video vide de una serie completa donde explico en detalle todo lo relacionado al manejo de memoria en el desarrollo de aplicaciones iOS con Swift. \nTe invito a ver la serie completa donde vas a estar viendo: ARC, Retain Cycle, Memory Leak entre otros.\n\nNo olvides dejar tus comentarios y regalarme un like, de esta forma me apoyas en seguir creando contenido.\n\nParte 2: Manejo de Memoria - ARC y Retain Cycle, Strong, Weak, Unowned - iOS\nhttps://bit.ly/3jJqhm5\n\nParte 3: Manejo de Memoria - ARC y Retain Cycle con Closures y Delegates - iOS\nhttps://bit.ly/3qmzrZM\n\n-- Timestamps --\n00:00 Introducción\n01:15 Memory \n02:31 Instancias almacenadas\n03:15 Exceso de uso de memoria\n04:28 Instancias huérfanas\n06:05 Reference Types\n06:38 Value Types\n07:16 Ejemplos de Value Types y Reference Types\n08:25 Dirección en memoria\n10:21 Dirección en memoria - Value Types\n12:27 Dirección en memoria - Reference Types\n15:27 Ejercicio en Xcode\n23:00 Debug Memory Graph\n25:01 Instancias de un Value Type\n26:17 Introducción la segunda parte de la explicación\n\nTwitter: \nhttps://twitter.com/VictorRoldanDev\n\n#ARC #ValueType #ReferenceType #iOSDevelopment #RetainCycle #MemoryLeak #MemoryManagement  #AutomaticReferenceCounting",
                "thumbnails": {
                    "default": {
                        "url": "https://i.ytimg.com/vi/BhM_dovPUmM/default.jpg",
                        "width": 120,
                        "height": 90
                    },
                    "medium": {
                        "url": "https://i.ytimg.com/vi/BhM_dovPUmM/mqdefault.jpg",
                        "width": 320,
                        "height": 180
                    },
                    "high": {
                        "url": "https://i.ytimg.com/vi/BhM_dovPUmM/hqdefault.jpg",
                        "width": 480,
                        "height": 360
                    },
                    "standard": {
                        "url": "https://i.ytimg.com/vi/BhM_dovPUmM/sddefault.jpg",
                        "width": 640,
                        "height": 480
                    },
                    "maxres": {
                        "url": "https://i.ytimg.com/vi/BhM_dovPUmM/maxresdefault.jpg",
                        "width": 1280,
                        "height": 720
                    }
                },
                "channelTitle": "Victor Roldan Dev",
                "playlistId": "PLT_OObKZ3CpuNE0t8rCWkArfpTgkJP9lm",
                "position": 0,
                "resourceId": {
                    "kind": "youtube#video",
                    "videoId": "BhM_dovPUmM"
                },
                "videoOwnerChannelTitle": "Victor Roldan Dev",
                "videoOwnerChannelId": "UC_I_lCplbwIf60iUgsTE79g"
            },
            "contentDetails": {
                "videoId": "BhM_dovPUmM",
                "videoPublishedAt": "2021-10-26T05:00:04Z"
            }
        },
        {
            "kind": "youtube#playlistItem",
            "etag": "yAL6A5mE1xhlcrCUL56z7T_8uTA",
            "id": "UExUX09PYktaM0NwdU5FMHQ4ckNXa0FyZnBUZ2tKUDlsbS4yODlGNEE0NkRGMEEzMEQy",
            "snippet": {
                "publishedAt": "2021-10-25T00:02:46Z",
                "channelId": "UC_I_lCplbwIf60iUgsTE79g",
                "title": "Manejo de Memoria - ARC y Retain Cycle, Strong, Weak, Unowned - iOS - Swift 2/3",
                "description": "En esta video te explico como funciona el Automatic Reference Counting y cómo se debe gestionar los reference types para evitar generar un Retain Cycle en swift. También aprende qué son referencias Strong, Weak y Unowned, y para qué se utilizan.\n\nNo olvides dejar tus comentarios y regalarme un like, de esta forma me apoyas en seguir creando contenido.\n\nParte 1: Manejo de Memoria - Value Type y Reference Type - iOS - Swift\nhttps://bit.ly/3bflhku\n\nParte 3: Manejo de Memoria - ARC y Retain Cycle con Closures y Delegates - iOS\nhttps://bit.ly/3qmzrZM\n\n-- Timestamps --\n00:00 Introducción\n00:48 Que es ARC o Automatic Reference Counting\n02:22 Ejemplo del contador de ARC\n06:24 Ejercicio de ARC - deinit\n10:11 Segundo ejemplo ARC\n14:56 Retain Cycle\n17:37 Strong, Weak, Unowned\n20:05 Resolviendo un Retain Cycle\n25:29 Ejercicio práctico Retain Cycle\n28:40 Instrument\n33:28 Introducción a la tercera parte de la explicación\n\nTwitter: \nhttps://twitter.com/VictorRoldanDev\n\n#ARC #RetainCycle #MemoryLeak #StrongWeakUnowned #iOSDevelopment  #MemoryManagement  #AutomaticReferenceCounting",
                "thumbnails": {
                    "default": {
                        "url": "https://i.ytimg.com/vi/lWZLs5BYLiM/default.jpg",
                        "width": 120,
                        "height": 90
                    },
                    "medium": {
                        "url": "https://i.ytimg.com/vi/lWZLs5BYLiM/mqdefault.jpg",
                        "width": 320,
                        "height": 180
                    },
                    "high": {
                        "url": "https://i.ytimg.com/vi/lWZLs5BYLiM/hqdefault.jpg",
                        "width": 480,
                        "height": 360
                    },
                    "standard": {
                        "url": "https://i.ytimg.com/vi/lWZLs5BYLiM/sddefault.jpg",
                        "width": 640,
                        "height": 480
                    },
                    "maxres": {
                        "url": "https://i.ytimg.com/vi/lWZLs5BYLiM/maxresdefault.jpg",
                        "width": 1280,
                        "height": 720
                    }
                },
                "channelTitle": "Victor Roldan Dev",
                "playlistId": "PLT_OObKZ3CpuNE0t8rCWkArfpTgkJP9lm",
                "position": 1,
                "resourceId": {
                    "kind": "youtube#video",
                    "videoId": "lWZLs5BYLiM"
                },
                "videoOwnerChannelTitle": "Victor Roldan Dev",
                "videoOwnerChannelId": "UC_I_lCplbwIf60iUgsTE79g"
            },
            "contentDetails": {
                "videoId": "lWZLs5BYLiM",
                "videoPublishedAt": "2021-10-28T05:00:14Z"
            }
        },
        {
            "kind": "youtube#playlistItem",
            "etag": "KyKWl76xGSX6R5QjyK4Ydrc9-ks",
            "id": "UExUX09PYktaM0NwdU5FMHQ4ckNXa0FyZnBUZ2tKUDlsbS4wMTcyMDhGQUE4NTIzM0Y5",
            "snippet": {
                "publishedAt": "2021-11-11T04:26:11Z",
                "channelId": "UC_I_lCplbwIf60iUgsTE79g",
                "title": "Manejo de Memoria - ARC y Retain Cycle con Closures y Delegates - iOS - Swift 3/3",
                "description": "En este vide te explico qué son los closures brevemente y principalmente me enfoco en cómo se generan los retain cycles utilizando closures. Vas a aprender como revisar estos memory leaks desde el memory graph debuger. También te enseño cómo se puede generar un retain cycle utilizando el patron Delegations y también te explico cómo puedes resolverlo. \nTe traigo todo este conocimiento en español para que lo entiendas al 100%.\n\nNo olvides dejar tus comentarios y regalarme un like, de esta forma me apoyas en seguir creando contenido.\n\nParte 1: Manejo de Memoria - Value Type y Reference Type - iOS - Swift\nhttps://bit.ly/3bflhku\n\nParte 2: Manejo de Memoria - ARC y Retain Cycle, Strong, Weak, Unowned - iOS\nhttps://bit.ly/3jJqhm5\n\n\n-- Timestamps --\n00:00 Introducción\n00:40 Resumen de la parte 2\n01:28 Introducción a Closures\n02:10 Ejemplo práctico de Closures\n06:09 Retain Cycle en Closures \n07:18 Capture List en Closures\n10:42 Automatic Reference Counting en Closures\n12:30 Ejemplo de Closures y Retain Cycles en Xcode\n20:47 Patrón Observer y Closures\n25:11 Debug Memory Graph  \n26:09 Debug Navigator - Memory\n27:48 Memory Leak desde el Debug Memory Graph\n31:30 DispatchQueue y Capture List\n35:15 Retain Cycles y el Patrón Delegations\n39:15 Diagrama para saber cuando se genera un Retain Cycle con Closures\n\nDiagrama Detección de Retain Cycles - Medium\nhttps://medium.com/flawless-app-stories/you-dont-always-need-weak-self-a778bec505ef\n\nTwitter: \nhttps://twitter.com/VictorRoldanDev\n\n#iOSDevelopment #RetainCycle #MemoryLeak #MemoryManagement #closures #weakself #unowned #delgationspatter",
                "thumbnails": {
                    "default": {
                        "url": "https://i.ytimg.com/vi/eLhG15kJws0/default.jpg",
                        "width": 120,
                        "height": 90
                    },
                    "medium": {
                        "url": "https://i.ytimg.com/vi/eLhG15kJws0/mqdefault.jpg",
                        "width": 320,
                        "height": 180
                    },
                    "high": {
                        "url": "https://i.ytimg.com/vi/eLhG15kJws0/hqdefault.jpg",
                        "width": 480,
                        "height": 360
                    }
                },
                "channelTitle": "Victor Roldan Dev",
                "playlistId": "PLT_OObKZ3CpuNE0t8rCWkArfpTgkJP9lm",
                "position": 2,
                "resourceId": {
                    "kind": "youtube#video",
                    "videoId": "eLhG15kJws0"
                },
                "videoOwnerChannelTitle": "Victor Roldan Dev",
                "videoOwnerChannelId": "UC_I_lCplbwIf60iUgsTE79g"
            },
            "contentDetails": {
                "videoId": "eLhG15kJws0",
                "videoPublishedAt": "2021-11-11T05:00:11Z"
            }
        }
    ],
    "pageInfo": {
        "totalResults": 3,
        "resultsPerPage": 5
    }
}
